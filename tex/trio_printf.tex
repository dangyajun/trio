% $Id$
%
% Copyright (C) 1998 Bjorn Reese and Daniel Stenberg.
%
% Permission to use, copy, modify, and distribute this software for any
% purpose with or without fee is hereby granted, provided that the above
% copyright notice and this permission notice appear in all copies.
%
% THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
% WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
% MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
% CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.

% FIXME: Create own Example environment

\documentclass{article}
\usepackage{latex2man}

\begin{Name}{3}{trio_printf}{Bjorn Reese and Daniel Stenberg}{libtrio}{trio_printf}
trio_printf,
trio_fprintf,
trio_sprintf,
trio_snprintf,
trio_snprintfcat,
trio_aprintf,
trio_vprintf,
trio_vfprintf,
trio_vsprintf,
trio_vsnprintf,
trio_vaprintf,
trio_printfv,
trio_fprintfv,
trio_sprintfv,
trio_snprintfv
- formatted output conversion
\end{Name}

\section{Synopsis}

\texttt{cc \Dots\ -ltrio -lm}

\texttt{\#include $<$trio.h$>$}

\texttt{int trio_printf(const char *format, ...);}\\
\texttt{int trio_fprintf(FILE *file, const char *format, ...);}\\
\texttt{int trio_dprintf(int fd, const char *format, ...);}\\
\texttt{int trio_sprintf(char *buffer, const char *format, ...);}\\
\texttt{int trio_snprintf(char *buffer, size_t max, const char *format, ...);}\\

\texttt{int trio_vprintf(const char *format, va_list args);}\\
\texttt{int trio_vfprintf(FILE *file, const char *format, va_list args);}\\
\texttt{int trio_vdprintf(int fd, const char *format, va_list args);}\\
\texttt{int trio_vsprintf(char *buffer, const char *format, va_list args);}\\
\texttt{int trio_vsnprintf(char *buffer, size_t bufferSize, const char *format, va_list args);}\\

\texttt{int trio_printfv(const char *format, void **args);}\\
\texttt{int trio_fprintfv(FILE *file, const char *format, void **args);}\\
\texttt{int trio_dprintfv(int fd, const char *format, void **args);}\\
\texttt{int trio_sprintfv(char *buffer, const char *format, void **args);}\\
\texttt{int trio_snprintfv(char *buffer, size_t bufferSize, const char *format, void **args);}\\

\texttt{int trio_snprintfcat(char *buffer, size_t max, const char *format, ...);}\\

\texttt{int trio_asprintf(char **buffer, const char *format, ...);}\\
\texttt{int trio_vasprintf(char **buffer, const char *format, va_list args);}

\section{Description}
This documentation is incomplete.
The documentation of the printf family in [C99] and [UNIX98] also applies
to the trio counterparts.

All these functions outputs a string which is formatted according to the
\Arg{format} string and the consecutive arguments. The \Arg{format} string
is described in the Formatting section below.

\textbf{trio_printf}, \textbf{trio_vprintf}, and \textbf{trio_printfv} writes
the output to the standard output stream (stdout).

\textbf{trio_fprintf}, \textbf{trio_vfprintf}, and \textbf{trio_fprintfv}
writes the output to a given output stream.

\textbf{trio_dprintf}, \textbf{trio_vdprintf}, and \textbf{trio_dprintfv}
writes the output to a file descriptor (this includes, for example, sockets).

\textbf{trio_sprintf}, \textbf{trio_vsprintf}, and \textbf{trio_sprintfv}
writes the output into \Arg{buffer}.

\textbf{trio_snprintf}, \textbf{trio_vsnprintf}, and \textbf{trio_vsnprintf}
writes \Arg{max} - 1 characters into \Arg{buffer} followed by a terminating
zero character. If \Arg{max} is 1, then \Arg{buffer} will be an empty string.
If \Arg{max} is 0, then \Arg{buffer} is left untouched, and can consequently
be \texttt{NULL}. The number of characters that would have been written to
\Arg{buffer}, had there been sufficient space, is returned.

\textbf{trio_snprintfcat} appends the formatted text at the end of
\Arg{buffer}.

\textbf{trio_asprintf} and \textbf{trio_vasprintf} allocates and returns a
string in \Arg{buffer} containing the formatted text.


\section{Formatting}

The \Arg{format} string can contain normal text and conversion indicators.
The normal text can be any character except the nil character
(ASCII 000 = '\Bs 0') and the percent character (ASCII 045 = '\%').
Conversion indicators consists of an indication character (\%), followed by
zero or more conversion modifiers, and exactly one conversion specifier.

\subsection{Modifiers}

Some modifiers exhibit the same behaviour for all specifiers, other modifiers
indicate different behaviours for different specifiers, and other modifiers
are only applicable to certain specifiers. The relationship is described for
each modifier. The number 9 is used to denotes an arbitary integer.

\begin{description}
\item Positional (9\$) [UNIX98]\\
Normally the arguments supplied to these functions are interpreted
incrementially from left to right. Arguments can be referenced specifically in
the format string. The modifier n\$ selects the nth argument. The first
argument is referred as 1\$. If this modifier is used, it must be the first
modifier after the indication character. n\$ can also be used for argument
width, precision, and base.\\
The performance penalty of using positionals is almost neglible (contrary to
most other printf implementations).\\
\begin{description}
\item[Mixing]\\
Mixing normal and positional specifiers is allowed [TRIO]. For example,
\texttt{trio_printf("\%d~\%3\$d~\%2\$d\Bs n", 1, 2, 3);} results in "1~3~2".\\
Arguments for the printf family are passed on the stack. On most platforms it
is not possible to determine the size of individual stack elements, so it is
essential that the format string corresponds exactly to the passed arguments.
If this is not the case, incorrect values may be put into the result.
\item[Reference Gap]\\
For the same reason it is also essential that the format string does not
contain any "gaps" in the positional arguments. For example,
\texttt{trio_printf("\%1\$d~\%3\$d\Bs n", 1, 2, 3);} is NOT allowed. The format
string parser has no knowledge about whether the second argument is, say, an
integer or a long double (which have different sizes).\\
[UNIX98] describes this as unspecified behaviour. [TRIO] will detect reference
gaps and return an error.
\item[Double Reference]\\
It is also not allowed to reference an argument twice or more. For example,
\texttt{trio_printf("\%1\$d~\%1\$lf\Bs n", 1);} is NOT allowed, because it
references the first argument as two differently sized objects.\\
[UNIX98] describes this as unspecified behaviour. [TRIO] will detect double
references and return an error.
\end{description}

The following two statements are equivalent
\begin{enumerate}
\item \texttt{trio_printf("|\%d~\%s|\Bs n", 42, "meanings");}\\
 |42 meanings|
\item \texttt{trio_printf("|\%1\$d~\%2\$s|\Bs n", 42, "meanings");}\\
 |42 meanings|
\end{enumerate}

\item Width (9)\\
Specifies the minimum width of a field. If the fields has less characters than
specified by the width, the field will be left adjusted and padded by spaces.
The adjustment and padding can be changed by the Alignment (-) and Padding (0)
modifiers.\\
The width is specified as a number. If an asterix (*) is used instead, the
width will be read from the argument list.\\
Prefixes, such as 0x for hexadecimal integers, are part of width.\\
\begin{enumerate}
\item \texttt{trio_printf("|\%10i|\Bs n", 42);}\\
 |~~~~~~~~42|
\end{enumerate}

\item Precision (.9)\\
The precision has different semantics for the various data types.
The precision specifies the maximum number of printed characters for strings,
the number of digits after the decimal-point for floating-point numbers,
the number of significant digits for the g (and G) representation of
floating-point numbers,
the minimum number of printed digits for integers.

\begin{enumerate}
\item \texttt{trio_printf("|\%10.8i|\%.8i|\Bs n", 42, 42);}\\
 |~~00000042|00000042|
\end{enumerate}

\item Base (..9) [TRIO]\\
Sets the base that the associated integer must be converted to. The base can
be between 2 and 36 (both included).

\begin{enumerate}
\item \texttt{trio_printf("|\%10.8.2i|\%10..2i|\%..2i|\Bs n", 42, 42, 42);}\\
 |~~00101010|~~~~101010|101010|
\item \texttt{trio_printf("|\%*.8.*i|\Bs n", 10, 2, 42);}\\
 |~~00101010|
\end{enumerate}

\item Padding (0)\\
Integer and floating point numbers are prepended by zeros. The number of
leading zeros are determined by the precision. If precision is not present,
width is used instead.

\item Short (h)\\
The argument is read as an (unsigned) \texttt{short int}.

\item Short short (hh) [C99, GNU]\\
The argument is read as an (unsigned) \texttt{char}.

\item Fixed size (I) [MSVC]\\
The argument is read as a fixed sized integer. The modifier is followed by
a number, which specifies the number of bits in the integer, and can be one
of the following
\begin{itemize}
\item I8
\item I16
\item I32
\item I64 (if 64-bits integers are supported)
\end{itemize}
Works only for integers (i, u, d, o, x, X)

\item Largest (j) [C99]\\
The argument is read as an \texttt{intmax_t}/\texttt{uintmax_t}, which is
defined to be the largest signed/unsigned integer.

\item Long (l)\\
An integral argument is read as an (unsigned) \texttt{long int}.
A string argument is read as a \texttt{wchar_t *}, and output as a multi-byte
character sequence.

\item Long long (ll) [C99, UNIX98, GNU]\\
The argument is read as an (unsigned) \texttt{long long int}.

\item Long double (L) [C99, UNIX98, GNU]\\
The argument is read as a \texttt{long double}.

\item ptrdiff_t (t) [C99]\\
The argument is read as a \texttt{ptrdiff_t}, which is defined to be the
signed integer type of the result of subtracting two pointers.

\item Quad (q) [BSD, GNU]\\
Corresponds to the long long modifier (ll).

\item Wide (w) [MISC]\\
For a string argument this is equivalent to \texttt{\%ls}.

\item size_t (z) [C99]\\
The argument is read as a \texttt{size_t}, which is defined to be the type
returned by the \texttt{sizeof} operator.

\item size_t (Z) [GNU]\\
Corresponds to the size_t modifier (z).

\item Alternative (\#)\\
Prepend radix indicator for hexadecimal, octal, and binary integer numbers
and for pointers.
Always add a decimal-pointer for floating-point numbers.
Escape non-printable characters for strings.

\item Spacing (\ )\\
Prepend leading spaces when necessary.

\item Sign (+)\\
Always prepend a sign to numbers. Normally only the negative sign is prepended
to a number. With this modifier the positive sign may also be prepended.

\item Alignment (-)\\
The output will be left-justified in the field specified by the width.

\item Argument (*)\\
Width, precision, or base is read from the argument list, rather than from
the formatting string.

\item Quote/Grouping (') [MISC]\\
Groups integers and the integer-part of floating-point numbers according to
the locale. Quote strings and characters.

\item Sticky (!) [TRIO]\\
The modifiers listed for the current specifier will be reused by subsequent
specifiers of the same group.\\
The following specifier groups exists
\begin{itemize}
\item Integers (i, u, d, o, x, X)
\item Floating-point (f, F, e, E, g, G, a, A)
\item Characters (c)
\item Strings (s)
\item Pointer (p)
\item Count (n)
\item Errno (m)
\item Group ([])
\end{itemize}
The sticky modifiers are active until superseeded by other sticky modifiers,
or the end of the format string is reached.\\
Local modifiers overrides sticky modifiers for the given specifier only.

\begin{enumerate}
\item \texttt{trio_printf("|\%!08#x|\%04x|\%x|\Bs n", 42, 42, 42);}\\
 |0x00002a|0x2a|0x00002a|
\end{enumerate}

\end{description}

\subsection{Specifiers}

\begin{description}
\item Percent (\%)\\
Produce a percent (\%) character. This is used to quote the indication
character. No modifiers are allowed. The full syntax is "\%\%".

\begin{enumerate}
\item \texttt{trio_printf("Percent~is~\%\%\Bs n");}\\
 Percent is \%
\end{enumerate}

\item Hex floats (a, A) [C99]\\
Output a hexadecimal (base 16) representation of a floating point number. The
number is automatically preceeded by 0x (or 0X). The exponent is 'p' (or 'P').

\begin{enumerate}
\item \texttt{trio_printf("|\%a|\%A|\Bs n", 3.1415, 3.1415e20);}\\
 |0x3.228bc|0X3.228BCP+14|
\end{enumerate}

\item Binary numbers (b, B) [MISC - SCO UnixWare 7]\\
DEPRECATED: Use Base \%..2i instead.

\item Character (c)\\
Output a single character.
\begin{itemize}
\item Quote (') [TRIO]\\
Quote the character
\end{itemize}

\item Decimal (d)\\
Output a decimal (base 10) representation of a number.
\begin{itemize}
\item Grouping (') [TRIO]\\
The number is separated by the locale thousand separator.
\end{itemize}
Assuming the thousand separator is comma and the grouping is set to 3
\begin{enumerate}
\item \texttt{trio_printf("|\%'ld|\Bs n", 1234567);}\\
 |1,234,567|
\end{enumerate}

\item Floating-point (e, E)\\
Output a decimal floating-point number.
The style is \textbf{[-]9.99e[-]9}, where
\begin{description}
\item[\textbf{\Lbr -\Rbr 9.99}] is the mantissa (as described for the f, F specifier),
\item[\textbf{e\Lbr -\Rbr 9}] is the exponent indicator (either e or E, depending on the floating-point specifier), followed by an optional sign and the exponent
\end{description}

% thousand separator in integer-part

\item Floating-point (f, F)\\
Output a decimal floating-point number.
The style is \textbf{[-]9.99}, where
\begin{description}
\item[\textbf{\Lbr -\Rbr}] is an optional sign (either + or -),
\item[\textbf{9}] is the integer-part (possibly interspersed with thousand-separators),
\item[\textbf{.}] is the decimal-point (depending on the locale), and
\item[\textbf{99}] is the fractional-part.
\end{description}

The following modifiers holds a special meaning for this specifier
\begin{itemize}
\item Alternative (\#) [C99]\\
Add decimal point.
\item Grouping (') [TRIO]\\
Group integer part of number into thousands.
\end{itemize}

\item Floating-point (g, G)\\
Output a decimal floating-point representation of a number. The format of
either the f, F specifier or the e, E specifier is used, whatever
produces the shortest result.

\item Integer (i)\\
Output a signed integer. Default base is 10.

\item Errno (m) [GNU]\\

\item Count (n)\\
Insert into the location pointed to by the argument, the number of octets
written to the output so far.

\item Octal (o)\\
Output an octal (base 8) representation of a number.

\item Pointer (p)\\
Ouput the address of the argument. The address is printed as a hexadecimal
number. If the argument is the \texttt{NULL} pointer the text "(nil)" will be
used instead.
\begin{itemize}
\item Alternative (\#) [TRIO]\\
Prepend 0x
\end{itemize}

\item String (s, S)\\
Output a string. The argument must point to a zero terminated string. If the
argument is the \texttt{NULL} pointer the text "(nil)" will be used
instead. \texttt{\%S} is equivalent to \texttt{\%ls}.

\begin{itemize}
\item Quote (') [TRIO]\\
Quote the string.
\item Alternative (\#) [TRIO]\\
Non-printable characters are converted into C escapes, or hexadecimal numbers
where no C escapes exists for the character. The C escapes, the hexadecimal
number, and all backslashes are prepended by a backslash (\Bs).\ The known
C escapes are
\begin{description}
\item \Bs a (ASCII 007) = alert
\item \Bs b (ASCII 010) = backspace
\item \Bs f (ASCII 014) = formfeed
\item \Bs n (ASCII 012) = newline
\item \Bs r (ASCII 015) = carriage return
\item \Bs t (ASCII 011) = horizontal tab
\item \Bs v (ASCII 013) = vertical tab
\end{description}
\end{itemize}

\begin{enumerate}
\item \texttt{trio_printf("|One~\%s~Three|One~\%'s~Three|\Bs n", "Two", "Two");}\\
 |One Two Three|One "Two" Three|
\item \texttt{trio_printf("|Argument~missing~\%s|\Bs n", NULL);}\\
 |Argument missing (nil)|
\item \texttt{trio_printf("|\%#s|\Bs n", "\Bs 007 \Bs a.");}\\
 |\Bs a \Bs a.|
\end{enumerate}

\item Unsigned (u)\\
Output an unsigned integer. Default base is 10.

\item Hex (x, X)\\
Output a hexadecimal (base 16) representation of a number.
\begin{itemize}
\item Alternative (\#)\\
Preceed the number by 0x (or 0X). The two characters are counted as part of
the width.
\end{itemize}

\item User-defined ($<$$>$) [TRIO]\\
Invoke user-defined formatting.
See \Cmd{trio_register}{3} for further detail.

\end{description}

\section{Return Values}
All functions returns the number of outputted characters. If an error occured
then a negative error code is returned [TRIO]. Note that this is a deviation
from the standard, which simply returns -1 (or EOF) and errno set
appropriately.
The error condition can be detected by checking whether the function returns
a negative number or not, and the number can be parsed with the following
macros. The error codes are primarily intended as debugging aide for the
developer.

\begin{description}
\item[TRIO_EINVAL] Invalid argument.
\item[TRIO_ETOOMANY] Too many arguments.
\item[TRIO_EDBLREF] Double argument reference.
\item[TRIO_EGAP] Argument reference gap.
\item[TRIO_ENOMEM] Out of memory.
\end{description}

Example:

\begin{verbatim}
int rc;

rc = trio_printf("%%r\n", 42);
if (rc < 0) {
  if (TRIO_ERROR_CODE(rc) != TRIO_EOF) {
    trio_printf("Error: %%s at position %%d\n",
                TRIO_ERROR_NAME(rc),
                TRIO_ERROR_POSITION(rc));
  }
}
\end{verbatim}

\section{See Also}
\Cmd{trio_scanf}{3}, \Cmd{trio_register}{3}


\section{Notes}
The printfv family uses an array rather than the stack to pass arguments.
This means that \texttt{short int} and \texttt{float} values will not be
handled by the default argument promotion in C. Instead, these values must
be explicitly converted with the Short (h) modifier in both cases.

Example:

\begin{verbatim}
void *array[2];
float float_number = 42.0;
short short_number = 42;

array[0] = &float_number;
array[1] = &short_number;

trio_printfv("%%hf %%hd\n", array); /* CORRECT */
trio_printfv("%%f %%d\n", array); /* WRONG */
\end{verbatim}


\section{Conforming To}
Throughout this document the following abbreviations have been used to
indicate what standard a feature conforms to. If nothing else is indicated
ANSI C (C89) is assumed.
\begin{description}
\item[C89] ANSI X3.159-1989
\item[C99] ISO/IEC 9899:1999
\item[UNIX98] The Single UNIX Specification, Version 2
\item[BSD] 4.4BSD
\item[GNU] GNU libc
\item[MSVC] Microsoft Visual C
\item[MISC] Other non-standard sources
\item[TRIO] Extensions specific for this package
\end{description}

\section{Legal Issues}
Copyright \copyright\ 1998-2000 Bjorn Reese and Daniel Stenberg.

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
