'\" t
.\" Manual page created with latex2man on Sat May 19 15:01:56 DST 2001
.\" NOTE: This file is generated, DO NOT EDIT.
.de Vb
.ft CW
.nf
..
.de Ve
.ft R

.fi
..
.TH "TRIO_REGISTER" "3" "19 May 2001" "libtrio "
.SH NAME
trio_register, 
trio_unregister 
\- callback functions for trio_printf 
.PP
.SH SYNOPSIS
.PP
cc ... \-ltrio \-lm
.PP
#include <trio.h>
.br
#include <triop.h>
.PP
void *trio_register(trio_callback_t callback, const char *namespace);
.br
void trio_unregister(void *handle);
.PP
const char *trio_get_format(void *ref);
.br
void *trio_get_argument(void *ref);
.PP
int trio_print_ref(void *ref, const char *format, ...);
.br
int trio_vprint_ref(void *ref, const char *format, va_list args);
.br
int trio_printv_ref(void *ref, const char *format, void **args);
.br
.PP
int trio_print_int(void *ref, int number);
.br
.PP
.SH DESCRIPTION
This documentation is incomplete. 
.PP
.SH USER\-DEFINED SPECIFIER
The user\-defined specifier consists of a start character (ASCII 074 = '<'), 
an optional namespace string followed by a namespace separator 
(ASCII 072 = ':'), a format string, and an end character (ASCII 076 = '>'). 
.PP
The namespace string can consist of alphanumeric characters, and is used to 
define a named reference (see below). The namespace is case\-sensitive. If no 
namespace is specified, then we use an unnamed reference (see below). 
.PP
The format can consist of any character except the end character ('>'), the 
namespace separator (':'), and the nil character (ASCII 000 = \\0). 
.PP
Any modifier can be used together with the user\-defined specifier. 
.PP
.SH REGISTERING
A user\-defined specifier must be registered before it can be used. 
Unregistered user\-defined specifiers are ignored. The 
.BR "trio_register"
function is used to register a user\-defined specifier. It takes two argument, 
a callback function and a namespace, and it returns a handle. The handle must 
be used to unregister the specifier later. 
.PP
The following example registers a user\-define specifier with the "my_namespace" 
namespace: 
.PP
my_handle = trio_register(my_callback, "my_namespace");
.PP
There can only be one user\-defined specifier with a given namespace. There 
can be an unlimited number (subject to maximum length of the namespace) of 
different user\-defined specifiers. 
.PP
Passing NULL as the namespace argument results in an anonymous reference. 
There can be an unlimited number of anonymous references. 
.PP
.SS REFERENCES
There are two ways that a registered callback can be called. Either the 
user\-defined specifier must contain the registered namespace in the format 
string, or the handle is passed as an argument to the formatted printing 
function. 
.PP
If the namespace is used, then a user\-defined pointer must be passed as an 
argument: 
.PP
trio_printf("<my_namespace:format>\\n", my_data);
.br
.PP
If the handle is used, then the user\-defined specifier must not contain a 
namespace. Instead the handle must be passed as an argument, followed by a 
user\-defined pointer: 
.PP
trio_printf("<format>\\n", my_handle, my_data);
.br
.PP
The two examples above are equivalent. 
.PP
There must be exactly one user\-defined pointer per user\-defined specifier. 
This pointer can be used within the callback function with the 
.BR "trio_get_argument"
getter function (see below). 
.PP
The format string is optional. It can be used within the callback function 
with the 
.BR "trio_get_format"
getter function. 
.PP
.SS ANONYMOUS REFERENCES
Anonymous references are specified by passing NULL as the namespace. 
.PP
The handle must be passed as an argument followed by a user\-defined pointer. 
No namespace can be specified. 
.PP
anon_handle = trio_register(callback, NULL);
.br
trio_printf("<format>\\n", anon_handle, my_data);
.br
.PP
.SS RESTRICTIONS
.TP
.B *
The length of the namespace string cannot exceed 63 characters. 
.TP
.B *
The length of the user\-defined format string cannot exceed 255 
characters. 
.TP
.B *
User\-defined formatting cannot re\-define existing specifiers. 
This restriction was imposed because the existing formatting specifiers have 
a well\-defined behaviour, and any re\-definition would apply globally to an 
application (imagine a third\-party library changing the behaviour of a 
specifier that is crusial to your application). 
.PP
.SH CALLBACK FUNCTION
The callback function will be called if a matching user\-defined specifier 
is found within the formatting string. The callback function takes one input 
parameter, an opaque reference which is needed by the private functions. It 
returns an int, which is currently ignored. The prototype is 
.PP
int (*trio_callback_t)(void *ref)
.PP
See the Example section for full examples. 
.PP
.SH PRINTING FUNCTIONS
The following printing functions must only be used inside a callback function. 
These functions will print to the same output medium as the printf function 
which invoked the callback function. For example, if the user\-defined 
specifier is used in an sprintf function, then these print functions will 
output their result to the same string. 
.PP
.SS ELEMENTARY PRINTING
There are a number of function to print elementary data types. 
.TP
.BR "trio_print_int"
Print a signed integer. For example:
.br
trio_print_int(42);
.TP
.BR "trio_print_uint"
Print an unsigned integer. 
.TP
.BR "trio_print_double"
Print a floating\-point number. 
.TP
.BR "trio_print_string"
Print a string. For example:
.br
trio_print_string("Hello World");
.br
trio_print_string(trio_get_format());
.TP
.BR "trio_print_pointer"
Print a pointer. 
.PP
.SS FORMATTED PRINTING
The functions 
.BR "trio_print_ref",
.BR "trio_vprint_ref",
and 
.BR "trio_printv_ref"
outputs a formatted string just like its printf 
equivalents. 
.PP
trio_print_ref(ref, "There are %d towels\\n", 42);
.br
trio_print_ref(ref, "%<recursive>\\n", recursive_writer, trio_get_argument());
.br
.PP
.SH GETTER AND SETTER FUNCTIONS
The following getter and setter functions must only be used inside a callback 
function. They can either operate on the modifiers or on special data. 
.PP
.SS MODIFIERS
The value of a modifier, or a boolean indication of its presence or absence, 
can be found or set with the getter and setter functions. 
The generic prototypes of the these getter and setter functions are 
.PP
int  trio_get_???(void *ref);
.br
void trio_set_???(void *ref, int);
.br
.PP
where ???
refers to a modifier. For example, to get the width of 
the user\-defined specifier use 
.PP
int width = trio_get_width(ref);
.br
.PP
.SS SPECIAL DATA
Consider the following user\-defined specifier, in its two possible referencing 
presentations. 
.PP
trio_printf("%<format>\\n", namespace_writer, argument);
.br
trio_printf("%<namespace:format>\\n", argument);
.br
.PP
.BR "trio_get_format"
will get the 
.BR "format"
string, and 
.BR "trio_get_argument"
will get the 
.BR "argument"
parameter. 
There are no associated setter functions. 
.PP
.SH EXAMPLES
The following examples show various types of user\-defined specifiers. Although 
each specifier is demonstrated in isolation, they can all co\-exist within the 
same application. 
.SS TIME
Print the time in the format "HOUR:MINUTE:SECOND" if "time" is specified inside 
the user\-defined specifier. 
.PP
.Vb
static int time_writer(void *ref)
{
  const char *format;
  time_t *data;
  char buffer[256];

  format = trio_get_format(ref);
  if ((format) && (strcmp(format, "time") == 0)) {
    data = trio_get_argument(ref);
    if (data == NULL)
      return \-1;
    strftime(buffer, sizeof(buffer), "%H:%M:%S", localtime(data));
    trio_print_string(ref, buffer);
  }
  return 0;
}
.Ve
.PP
.Vb
int main(void)
{
  void *handle;
  time_t now = time(NULL);

  handle = trio_register(time_print, "my_time");

  trio_printf("%<time>\\n", handle, &now);
  trio_printf("%<my_time:time>\\n", &now);

  trio_unregister(handle);
  return 0;
}
.Ve
.PP
.SS COMPLEX NUMBERS
Consider a complex number consisting of a real part, re, and an imaginary part, 
im. 
.PP
.Vb
struct Complex {
  double re;
  double im;
};
.Ve
This example can print such a complex number in one of two formats. 
The default format is "re + i im". If the alternative modifier is used, then 
the format is "r exp(i theta)", where r is the length of the complex vector 
(re, im) and theta is its angle. 
.PP
.Vb
static int complex_print(void *ref)
{
  struct Complex *data;
  const char *format;

  data = (struct Complex *)trio_get_argument(ref);
  if (data) {
    format = trio_get_format(ref);
    
    if (trio_get_alternative(ref)) {
      double r, theta;
      
      r = sqrt(pow(data\->re, 2) + pow(data\->im, 2));
      theta = acos(data\->re / r);
      trio_print_ref(ref, "%#f exp(i %#f)", r, theta);
      
    } else {
      trio_print_ref(ref, "%#f + i %#f", data\->re, data\->im);
    }
  }
  return 0;
}
.Ve
.PP
.Vb
int main(void)
{
  void *handle;

  handle = trio_register(complex_print, "complex");

  /* Normal format. With handle and the with namespace */
  trio_printf("%<>\\n", handle, &complex);
  trio_printf("%<complex:>\\n", &complex);
  /* In exponential notation */
  trio_printf("%#<>\\n", handle, &complex);
  trio_printf("%#<complex:unused data>\\n", &complex);

  trio_unregister(handle);
  return 0;
}
.Ve
.PP
.SH RETURN VALUES
.BR "trio_register"
returns a handle, or NULL if an error occured. 
.PP
.SH NOTES
trio_register
and trio_unregister
are not thread\-safe. 
In multi\-threaded applications they must be guarded by mutexes. 
.PP
.SH SEE ALSO
.I "trio_printf"
(3)
.PP
.SH LEGAL ISSUES
Copyright (C) 1998\-2000 Bjorn Reese and Daniel Stenberg. 
.PP
Permission to use, copy, modify, and distribute this software for any 
purpose with or without fee is hereby granted, provided that the above 
copyright notice and this permission notice appear in all copies. 
.PP
THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED 
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF 
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND 
CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER. 
.\" NOTE: This file is generated, DO NOT EDIT.
